[
    {
        "id": 1,
        "title": "Laravel: Customizing Route Binding Logic",
        "slug": "laravel-customizing-route-binding-logic",
        "excerpt": "In Laravel, customizing route model binding allows you to add custom logic to the process of retrieving a model based on its ID. This article demonstrates how to use a custom parameter and the bind method to guarantee that visitors cannot access an unpublished post. Clear code examples are provided to help implement this solution.",
        "content": "We all know how route model binding works in Laravel. For instance, if you want to display a single post, you would write something like this in your code:\n\n```php\n\/\/ Route file\nRoute::get('posts\/{post}', [PostController::class, 'show'])->name('posts.show');\n\n\/\/ Controller\nclass PostController\n{\n    public function show(Post $post): View\n    {\n        return view('posts.show', compact('post'));\n    }\n}\n```\n\nIn this example, the route model binding retrieves an instance of the post model based on the post ID. If a visitor wants to view the post with an ID of 1, they can access it using the posts.show route.\n\nHowever, what if you need to add custom logic? For example, if you don't want visitors to see an unpublished post, you can add a check in the show method like this:\n\n```php\npublic function show(Post $post): View\n{\n    if (! $post->is_published) {\n        abort(404);\n    }\n\n    return view('posts.show', compact('post'));\n}\n```\nBut this solution only takes care of the problem within the show view. To guarantee that visitors cannot access an unpublished post, you need to add the same check in every method that depends on a post being published.\n\nA better solution is to customize the binding logic. Here's how you can do that:\n\n```php\n\/\/ Route file\nRoute::get('posts\/{published_post}', [PostController::class, 'show'])->name('posts.show');\nRoute::bind('published_post', function ($value) {\n    return Post::query()\n        ->where('id', $value)\n        ->published()\n        ->firstOrFail();\n});\n\n\/\/ Controller\nclass PostController\n{\n    public function show(Post $post): View\n    {\n        return view('posts.show', compact('post'));\n    }\n}\n```\nThe bind method returns a 404 error for any unpublished post. Now, wherever you need to use the post parameter in the visitors' domain, you can use the `published_post` parameter to guarantee that visitors cannot access an unpublished post.\n\nAlternatively, the bind logic can be moved to the boot method of the route service provider if desired, rather than being placed in the route file.\n\nHappy coding!\n\n> Note: The last code snippet assumes that you have a `published` scope in the `Post` model.\n",
        "published_at": "2023-02-03T18:48:02.000000Z",
        "status": "published",
        "post_type": "post",
        "is_menu_item": false,
        "og_image_url": "laravel-customizing-route-binding-logic.png",
        "author_id": 2,
        "created_at": "2023-05-23T22:00:57.000000Z",
        "updated_at": "2023-05-23T22:00:57.000000Z"
    },
    {
        "id": 2,
        "title": "Style Your Command Outputs The Laravel Way",
        "slug": "style-your-command-outputs-the-laravel-way",
        "excerpt": "Yesterday I was going through a command written by one of my colleague to help us seed permissions in an easier way. I was going to add it to our office Laravel skeleton (Laravel with extra functionality to make our life easier). Just I was about to add it, I thought why not use same styling used by Laravel to style the command output. So I dug into Laravel\u00e2\u20ac\u2122s code.",
        "content": "If you have used the latest version of Laravel ^9.23, you should have noticed that Laravel had improved their command output styling greatly.\n\nYesterday I was going through a command written by one of my colleague to help us seed permissions in an easier way. I was going to add it to our office Laravel skeleton (Laravel with extra functionality to make our life easier). Just I was about to add it, I thought why not use same styling used by Laravel to style the command output. So I dug into Laravel\u00e2\u20ac\u2122s code.\n\nLike everything in Laravel, it didn't take long to figure out how they were passing outputs. Laravel uses different view components to get the desired results.\n\nThere are multiple such components and I am gonna cover most common components here.\n\nIf you want to go see the components yourself, check vendors\\laravel\\framework\\src\\ Illuminate\\Console\\View \\Components folder in your Laravel project.\n\nBelow is the list of ways you can style your outputs.\n\n```php\n  \/**\n     * Execute the console command.\n     *\n     * @return int\n     *\/\n    public function handle(): int\n    {\n        \/\/ Line Styling\n        $this->components->alert('This is an alert.');\n        $this->components->info('This is a test command.');\n        $this->components->error('This is an error.');\n        $this->components->warn('This is a warning.');\n        $this->components->line('info', 'This is a test command.'); \/\/ info, error, warn\n\n        \/\/ Prompts\n        $this->components->choice('This is a choice.', ['a', 'b', 'c']);\n        $this->components->confirm('This is a confirm.');\n\n        \/\/ Tasks\n        $this->components->task('Running A Task', function () {\n            sleep(1);\n        });\n\n        \/\/ Other styles\n        $this->components->twoColumnDetail('First', 'Second');\n\n        $this->components->bulletList([\n            'This is a bullet list item.',\n            'This is another bullet list item.',\n        ]);\n\n        return 0;\n    }\n```\n\nThe following is the corresponding outputs.\n![Console Output](\nhttps:\/\/abunooh.com\/storage\/uploads\/qJ3Zrj791OWAMXD0JKuUj0pt8oc03WjtZ9BywBx6.png)\n\nIf you like these, you can go code diving to see more cool stuff like progress bar and tables.\n\nThat\u00e2\u20ac\u2122s it for today, have a good day!\n",
        "published_at": "2022-08-11T20:19:16.000000Z",
        "status": "published",
        "post_type": "post",
        "is_menu_item": false,
        "og_image_url": "style-your-command-outputs-the-laravel-way.png",
        "author_id": 2,
        "created_at": "2023-05-23T22:00:58.000000Z",
        "updated_at": "2023-05-23T22:00:58.000000Z"
    },
    {
        "id": 3,
        "title": "Eloquent: One To One Relationships",
        "slug": "eloquent-one-to-one-relationships",
        "excerpt": "One to one is a very simple relationship but often not used. So time to time you may need to refer to documentation or google it to understand the relationship better. So here is my effort to make your life a little bit easier.",
        "content": "## Introduction\n\nOne to one is a very simple relationship. It says for a single model, it should belong to or own a single another type of model instance. Let me elaborate on that further with an example. Lets say we have a database of citizens and database of passports. A single citizen must not have more than one passport and a passport should not belong to more than one citizen. This is a one to one relationship.\n\n## ERD\nWe will be using the following Entity relationship diagram to demonstrate one to one relationship.\n![One to one ERD](https:\/\/abunooh.com\/storage\/uploads\/V3es62KxBb0XuaTlm6ROyH5YKwz34MNdDKHaQI6b.png \"One To One ERD\")\n\n## Generate Files\nI will be spinning up a new laravel install using the following command and I am going to call it article-demos.\nAfter that I am going to create required migrations and models.\n```bash\nlaravel new article-demos\ncd article-demos\nphp artisan make:model Citizen -m\nphp artisan make:model Passport -m\n```\nNow you should have migrations and models in your project. Lets continue.\n\n## Migrations\n\nLets create the very basics of these tables to get a better idea.\n\n```php\n\/\/ Citizens table migration\nSchema::create('citizens', function (Blueprint $table) {\n    $table->id();\n    $table->string('name');\n    $table->timestamps();\n});\n```\n```php\n\/\/ Passport table migration\nSchema::create('passports', function (Blueprint $table) {\n    $table->id();\n    $table->string('passport_number')->unique();\n    $table->date('expire_at');\n    $table->foreignId('citizen_id')->constrained()->cascadeOnDelete();\n  \t$table->timestamps();\n});\n```\n\nAfter we migrate the above table, we should have in our database; a citizens table with an id and name, and passports table with an id, passport number, expire_at and citizen_id. Notice that we have a foreign key in the passports table. It makes sense to put the foreign key in the passports table as a citizen may exist without a passport but a passport cannot exist without an owner\/citizen.\n\n\n\n> **Note:** You may notice that this table structure looks a lot like a one to many relationship, as we *can* have multiple instances of passports with same citizen_id. You would not be incorrect if you think that, but we will enforce the one to one mapping in the application level. If you don't know what I am talking about one to many relationship, don't worry, you will understand when we cover the one to many relationships.\n\n\n\n## Models\n\nNow lets create our models and enforce the one to one relationship.\n\n```php\nclass Citizen extends Model\n{\n\n    protected $fillable = [\n        'name'\n    ];\n\n    \/**\n    * Laravel will assume that the foreign key in passports\n    * table will be named as citizen_id. If not, you\n    * are required to provide the foreign key name\n    * as a second parameter. eg: owner_id\n    *\/\n    public function passport(): HasOne\n    {\n        return $this->hasOne(Passport::class);\n    }\n}\n```\n```php\nclass Passport extends Model\n{\n\n    protected $fillable = [\n        'passport_number',\n        'expire_at',\n    ];\n\n    protected $casts = [\n        'expire_at' => 'date'\n    ];\n\n    \/**\n    * Here since we named the relationship method as citizen,\n    * eloquent will assume that the foreign key name\n    * will be citizen_id, which is correct. But if\n    * we have named owner() as the method name,\n    * we would be required to pass a second\n    * parameter defining the foreign key\n    *\/\n    public function citizen(): BelongsTo\n    {\n        return $this->belongsTo(Citizen::class);\n    }\n}\n```\n*Don't forget to import the HasOne and BelongsTo classes*\n\nIt is as simple as that. The one to one relationship setup is done. I admire the readability of the Laravel relationship names. Just try saying \"A **Citizen** ***hasOne*** **Passport**, and a **Passport** ***belongsTo*** a **Citizen**\"\n\n## Saving, Updating & Deleting\n\nYou may use any of the following methods to save or update your relationships depending on the use case.\n\n```php\n$citizen = Citizen::create(['name' => 'Afeef']); \/\/ this will throw an error if you have not added name field to fillable fields\n\n$passport = new Passport();\n$passport->passport_number = \"E0000001\";\n$passport->expire_at = now()->addYears(5);\n\n\/\/ Option 1: Not recommended\n$passport->citizen()->associate($citizen);\n$passport->save();\n\n\/\/ Option 2: Recommended\n$citizen->passport()->save($passport);\n\n\/\/ Option 3:\n$citizen->passport()->create([\n  'passport_number' => 'E000020',\n  'expire_at' => now()->addYears(5),\n]);\n\n\/\/ Updating\n$citizen->passport->update(['passport_number' => 'EXXXX001']);\n\n\/\/ To delete\n\/\/ Direct delete\n$passport->delete();\n\n\/\/ Or delete via relationship\n$citizen->passport()->delete();\n```\n\n## Querying\n\n```php\n\/\/ You can load relationship using with as any other relationship\nCitizen::query()->with('passport')->get();\nPassport::query()->with('citizen')->get();\n\n\/\/ You can access relationship attributes as follows\n$citizen->passport?->passport_number;\n$passport->citizen?->name;\n```\n\n## Things To Keep In Mind\nSuppose you created a citizen with name Ali, and a passport for him, as below\n```php\n$citizen = Citizen::create(['name' => 'Ali']);\n$citizen->passport()->create([\n  'passport_number' => 'FIRSTPASSPORT',\n  'expire_at' => now()->addYears(5),\n]);\n```\nYou can create another passport and associate it with same citizen. However, you will only get the first created passport through the hasOne relationship.\n```php\n\/\/ The below code will create a second passport for the same citizen.\n$passport2 = new Passport();\n$passport2->passport_number = 'SECONDPASSPORT';\n$passport2->expire_at = now()->addYears(10);\n$passport2->citizen()->associate($citizen);\n\n\/\/ However if you fetch the passport via citizen, you will still get the first passport.\n$citizen->passport?->passport_number; \/\/ will be equal to 'FIRSTPASSPORT'\n```\n\nYou may want it that way, or not. If you do not want it to behave this way, there are couple of things you can do.\nFirstly, you can add a unique constraint to passports' citizen_id foreign key as below\n```php\n$table->foreignId('citizen_id')->unique()->constrained()->cascadeOnDelete();\n```\nNote that this will throw an error if you try to save a second passport with same citizen id.\n\nSecondly, before creating a new passport, you may query for an existing record and then update it if it exists, or create it if it does not.\n```php\n$citizen->passport()\n  ->updateOrCreate(\n\t['passport_number' => '#345453'],\n\t['expire_at' => now()->addMonth()]\n  );\n```\nYou may also use both depending on your preference.\n\nThat's it I believe. If you have any questions, or suggestions, let me know and I will update the post as required. Happy coding!\n",
        "published_at": "2022-04-23T21:22:32.000000Z",
        "status": "published",
        "post_type": "post",
        "is_menu_item": false,
        "og_image_url": "eloquent-one-to-one-relationships.png",
        "author_id": 2,
        "created_at": "2023-05-23T22:01:00.000000Z",
        "updated_at": "2023-05-23T22:01:00.000000Z"
    },
    {
        "id": 4,
        "title": "Consider an intermediate level refactor",
        "slug": "consider-an-intermediate-level-refactor",
        "excerpt": "Your file structure is growing. It is not big enough to go DDD yet, neither small enough to follow default Laravel structure. What will you do?",
        "content": "## Problem\nWhen making a simple application with Laravel, its given folder structure is good enough without any changes. That is, controllers with controllers, models with models and views with views. But if you see your project growing into something that will be difficult to navigate with given folder structure, then mostly it is recommended to go Modular or DDD (Domain Driven Development). However, in my opinion, both of these approaches are still applied to \"big\" projects.\n\nBut what if your project is neither small nor big? It's just right there, where you kind of want to refactor to one of the mentioned approaches, but you know that doing so might not be the best solution and keeping it as it is, is also creating a bit of hassle to navigate through your code. I know that feeling, I have been there a few times.\n\n## Solution\nWhat I found the best approach was to refactor a little with no major changes to the default structure. That is to group module specific classes within the controllers, models and views.\nLet me explain a bit more. For example, I have to implement a grant feature in my current project. Which allows users to open grants and members can submit proposals for the grants, then users can process the proposal requests and award members accordingly and track reports submitted by members for the awarded grant. So there are few models involved in the feature, like: Grant Type, Grant. Grant Proposal, Grant Awards, Reports, etc.\n\nThe project has lots of other features and putting everything in models, views and controllers without refactoring makes navigation a lot time-consuming. However, as said, I do not want to go full modular or DDD either. I just want something in between. So I just created a Grants folder in Models and moved everything there. Any model that is related to this feature is going into the \u00e2\u20ac\u0153App\\Models\\Grants\u00e2\u20ac\u009d folder. Likewise, any controller related to grants is going to the \u00e2\u20ac\u0153App\\Http\\Controller\\Admin\\Grants\u00e2\u20ac\u009d folder and any view that is related to the grant feature is going to the \u00e2\u20ac\u0153resources\/views\/admin\/grants\u00e2\u20ac\u009d folder.\n\nThis way it is still using the default structure (almost), however just this small refactor into a separate folder gives much better readability and accessibility.\n",
        "published_at": "2021-10-25T19:24:38.000000Z",
        "status": "published",
        "post_type": "post",
        "is_menu_item": false,
        "og_image_url": "consider-an-intermediate-level-refactor.png",
        "author_id": 2,
        "created_at": "2023-05-23T22:01:02.000000Z",
        "updated_at": "2023-05-23T22:01:02.000000Z"
    },
    {
        "id": 5,
        "title": "How to implement model states using spaties laravel model state package",
        "slug": "how-to-implement-model-states-using-spaties-laravel-model-state-package",
        "excerpt": "Sometimes handling the status of a given record is a pain. You may need to fire events, check if the model can change to the desired status or if the user is authorized to make the change and lot more. In this post, I will be covering a spatie package to help solve this issue.",
        "content": "## Introduction\nOften times you will need to change the state of your model and perform different actions based on the current state of the model. For example, my blog currently doesnt support drafting, publishing or any of those for the post model. Hence everything I write, is available to public as soon as I save it.\n\nWhat I want is to have a state field in my posts table and to publicize the posts based on the state of the post. For now, I just want 2 states: publish and draft and nothing more. But down the line, I may need to schedule the posts too, but lets keep that for another day. So lets get started!\n\n## Migration\nFirst of all I would need to add the state field to migrations. I can use a modification migration or just modify the current posts table migration and run a migration fresh command. Since I have only one more post, I can take the backup very easily. So ill go with that option instead of a modification migration. So in my posts table migration I am going to add one more field.\n\n```php\nSchema::create('posts', function (Blueprint $table) {\n            \/\/ migration columns\n            $table->string('state');\n        });\n```\n\n**Note:** If you are adding a modification migration, you may need to add a default value or make the state nullable.\n\nNow I need to add spatie\/laravel-model-states. Run the following command to install the package\n```bash\ncomposer require spatie\/laravel-model-states\n```\nNow add the necessary traits and changes to the Post model.\n\n```php\nnamespace App\\Models;\n\nuse App\\States\\Post\\PostState;\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Spatie\\ModelStates\\HasStates;\n\nclass Post extends Model\n{\n    use HasFactory;\n    use HasStates;\n\n    protected $casts = [\n        'state' => PostState::class,\n    ];\n\n   \/\/ the rest of the model code\n```\nDid you notice that I have a PostState class imported? Don't worry, we are going to create that now. This will be the abstract class that is going to control all the Post states. I am going to put these in a seperate folder under apps directroy. I am also going to add one more folder for the Post model as I know I will soon need to add states for other models too.\nSo now I have created the following file in app\/States\/Post directory and called it PostState.php\n```php\n<?php\n\nnamespace App\\States\\Post;\n\nuse Spatie\\ModelStates\\Exceptions\\InvalidConfig;\nuse Spatie\\ModelStates\\State;\nuse Spatie\\ModelStates\\StateConfig;\n\nabstract class PostState extends State\n{\n    \/**\n     * @return StateConfig\n     * @throws InvalidConfig\n     *\/\n    public static function config(): StateConfig\n    {\n        return parent::config()\n            ->default(Draft::class);\n    }\n}\n```\nOnce again, we are setting a default state as Draft::class. This is the state the model will be saved by default. You will not have to provide any value for the state when saving the model (in this case a post). As you konw a draft class does not exist at this point. So lets create that too.\n```php\n<?php\n\nnamespace App\\States\\Post;\n\nclass Draft extends PostState\n{\n       protected static $name = 'draft';\n}\n```\nThis Draft.php file is also created within the app\/States\/Post directoy. I have also added a static variable of name, this as per the documentation will override the default way of saving the whole namespace of the class (eg: App\\States\\Post\\Draft) to just given name in the variable. (eg: 'draft'). This seems very reasonable change as I might want to move the namespace of the states to somewhere else and saving the whole namespace of a class into the database will not be very scalable, in my humble opionion. You are free to do whatever you want.\n\nLets add one more state of published.\n```php\nnamespace App\\States\\Post;\n\nclass Published extends PostState\n{\n       protected static $name = 'published';\n}\n```\nNow lets add the allowed transitions to PostState abstract class we created earlier. I want the following to happen\n\n- Save the posts in draft state by default (already implemented)\n- Allow posts to be published if it is in draft state\n- Allow posts to be drafted if it is in published state\nSo the config function of PostState class will be updated as below\n```php\n   public static function config(): StateConfig\n    {\n        return parent::config()\n            ->default(Draft::class) \/\/ default saving state\n            ->allowTransition(Draft::class, Published::class) \/\/ allows transition from draft to published\n            ->allowTransition(Published::class, Draft::class); \/\/ allows transition from published to draft\n    }\n```\n\n## Views\nAs I am going to save the posts in draft format, I want to be able to change its state by visiting to its show view.\n```php\nRoute::get('posts\/{post}', [PostsController::class, 'show'])->name('posts.show');\n```\nThis takes me to the show view of the post. The view is how I want the final product to be. (Please don\u00e2\u20ac\u2122t mind the unfinished stuff, this is a hobby and I have not had enough time to finish the customization)\n\nI want the state changes to go between the header and the post details. So ill be adding a _state.blade.php view to the current show.blade.php\n```php\n<!-- _show.blade.php -->\n@extends('admin.posts.posts')\n\n@section('content')\n\n    @include('admin.posts._state') \/\/ newly added state view\n    @include('admin.posts._details')\n\n@endsection\n\n<div class=\"bg-white shadow overflow-hidden sm:rounded-lg p-4 text-gray-700 mb-4\">\n    {!! Form::open(['route' => ['admin.posts.state-transit', $post], 'method' => 'PUT']) !!}\n\n        @if ($post->state->canTransitionTo(\\App\\States\\Post\\Published::class))\n            <x-btn-no-class type=\"submit\"\n                            class=\"bg-blue-300 border-blue-400 text-blue-700 hover:bg-blue-400\"\n                            name=\"action\"\n                            value=\"published\">\n                Publish\n            <\/x-btn-no-class>\n        @endif\n\n        @if ($post->state->canTransitionTo(\\App\\States\\Post\\Draft::class))\n            <x-btn-no-class type=\"submit\"\n                            class=\"bg-gray-300 border-gray-400 text-gray-700 hover:bg-gray-400\"\n                            name=\"action\"\n                            value=\"draft\">\n                Draft\n            <\/x-btn-no-class>\n        @endif\n\n    {!! Form::close() !!}\n<\/div>\n\n```\nHere we are adding a form that will be submit a put request to \/posts\/{post}\/state-transit endpoint. Yes, we have not yet created this. We are also adding two buttons for state change. One is publishing button which will be displayed if the post allows publishing. Remember back in PostState we set a rule that post will only be able to change to published state if and only if the posts current state is draft.\n\nLike this, we have also added a draft button which will also be displayed if the post allows it to be transited to draft state. This can be extremely helpful if you have many states or when you want to add more states to post.\n\ncanTransitionTo() method is provided by the package, you don\u00e2\u20ac\u2122t need to implement this on your own. The method checks the allowTransition methods given in the config of PostState class.\nSo now lets add the put route in place.\n```php\nRoute::match(['PUT', 'PATCH'], 'posts\/{post}\/state-transit', [PostsController::class, 'stateTransit'])->name('posts.state-transit');\n```\nThis will direct the request to a method names stateTransit in PostsController class. So lets add the class.\n```php\n\/\/ PostsController.php\n    public function stateTransit(Post $post, Request $request)\n    {\n        \/\/ logic\n    }\n```\nOk we have created the form, added the routes and the controller method. Remaining is\nValidating the request\nChecking authorization of user to perform the specific action\nPerforming the action and redirecting to the page\nLets validate the request first, ill do it within the controller to make it simple, you may extract the validation to a request class if you like.\n```php\n$request->validate([\n            'action' => new ValidStateRule(PostState::class)\n        ]);\n```\nHere I am using the rules provided by spatie to validate the states. Once validated, now I can retrieve the state class using make method then call transitionTo on post to transit to the given method. But since we are restricting some transitions, its likely that a user might do something (like double clicking the transition button) that may throw a TransitionNotFound exception. So I will handle that as well.\n```php\n       $state_class = PostState::make($request->action, $post);\n\n        try {\n            $post->state->transitionTo($state_class);\n        } catch (TransitionNotFound $exception) {\n            flash()->error(\"Transition not found\");\n            return redirect()->back();\n        }\n        return redirect()->back();\n```\nNote that the flash()->error(), that\u00e2\u20ac\u2122s another one of spaties package for flashing a message. You may use it or not, but the point here is handling the exception gracefully. Since all the logic and work is done, remaining is a redirect to the previous page. With this all the parts should be working and you (if followed) should have implemented state transitioning to your model.\n\nCouple of things you can do more is,\nAdding a permission to state transition. You can do this by creating a custom transition class and adding a canTransition metod. This will also throw a TransitionNotAllowed exception on failure, so make sure to handle that too.\n\nIf you are adding a permission, add the permission check using @can to blade file too. You would not be wanting the user see a button he\/she can not use.\n\nThat\u00e2\u20ac\u2122s it for today. If you find this guide helpful, please share!\n\nPeace!\n",
        "published_at": "2021-02-20T19:00:02.000000Z",
        "status": "published",
        "post_type": "post",
        "is_menu_item": false,
        "og_image_url": "how-to-implement-model-states-using-spaties-laravel-model-state-package.png",
        "author_id": 2,
        "created_at": "2023-05-23T22:01:04.000000Z",
        "updated_at": "2023-05-23T22:01:04.000000Z"
    },
    {
        "id": 6,
        "title": "About me",
        "slug": "about-me",
        "excerpt": "Senior full-stack web developer and a logo designer.",
        "content": "Hey, I am Hussain! I'm a senior full-stack web developer at Javaabu Pvt Ltd (a small software firm based in Maldives). I have recently finished my bachelor's degree in Computer Science at Maldives National University. I also hold a bachelor's degree in Islamic Studies.\n\n\nWelcome to my personal website, where I share my thoughts, ideas, works, anything and everything I want. One more thing, I love coding, fishing and learning new stuff that interests me.\n\n\nIf you are wondering about the website name, I have a son named Nooh. Abu nooh (in Arabic) means, I am the father of Nooh. So you can now stop wondering about that!\n\n\nCheck out the portfolio page (currently in development) to see a highlight of the projects I've made, and blog to see everything I've written.\n\n\n**Connect**\n\n- [GitHub](https:\/\/github.com\/ibnnajjaar)\n\n",
        "published_at": "2023-02-28T19:00:00.000000Z",
        "status": "published",
        "post_type": "page",
        "is_menu_item": true,
        "og_image_url": "about-me.png",
        "author_id": 2,
        "created_at": "2023-05-23T22:01:05.000000Z",
        "updated_at": "2023-05-25T03:01:33.000000Z"
    },
    {
        "id": 7,
        "title": "Adding a Custom Open Graph Image to Posts",
        "slug": "adding-a-custom-open-graph-image-to-posts",
        "excerpt": "This article shows you how to use a package to create custom Open Graph images for your Laravel-backed blog posts. By following our guide, you can enhance your website's visual appeal and shareability on social media. This is ideal for bloggers, developers, and website owners looking to increase their online presence and visibility.",
        "content": "As I migrated my blog from Nova to Filament, I realized that I needed to add a better Open Graph image to improve the visibility and shareability of my content. After some research, I developed a package that simplifies the process of creating custom Open Graph images for anyone facing the same challenge. In this article, I will guide you through the package and show you how to customize it to suit your specific requirements. This article is ideal for bloggers, developers, and website owners who want to optimize their content for social media and search engines.\n\nThe package was created using Spatie Browsershot, which requires Puppeteer to function. Therefore, you will need to install Puppeteer before using the package. For instructions on how to install it, you can refer to the Spatie Browsershot documentation requirements.\n\nSuppose we want to add an Open Graph image to each post on our blog. For the purposes of this article, let's assume that our post model has a title, a unique slug, content, author's name, and an Open Graph image URL. Here is our post migration schema:\n\n```php\nSchema::create('posts', function (Blueprint $table) {\n    $table->id();\n    $table->string('title');\n    $table->string('slug')->unique();\n    $table->string('author_name');\n    $table->text('content')->nullable();\n    $table->string('og_image_url')->nullable();\n    $table->timestamps();\n});\n```\n\n> **Note:** by default the package will look for `og_image_url` field, however you can customize this behavior. Refer to [documentation](https:\/\/ibnnajjaar.gitbook.io\/graphify\/basic-usage\/preparing-your-model) for more information.\n> \n\nThe first thing we need to do is install the package. Use the following Composer command:\n\n```bash\ncomposer require ibnnajjaar\/graphify\n```\n\nThen, we are going to publish the configuration file using the following Artisan command:\n\n```bash\nphp artisan vendor:publish --tag=\"graphify-config\"\n```\n\nNow we are going to modify our post model as required.\n\n```php\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Ibnnajjaar\\Graphify\\Support\\HasGraphify;\nuse Ibnnajjaar\\Graphify\\Support\\GraphifyTrait;\n\nclass Post extends Model implements HasGraphify\n{\n    use GraphifyTrait;\n}\n```\n\nThat is pretty much it. Now, the post should generate an OG image every time we create one. To include the generated image in our blog meta tags, we are going to add the following meta tags:\n\n```php\n<meta property=\"og:image\" content=\"{{ $post->graphify_image }}\">\n<meta name=\"twitter:image\" content=\"{{ $post->graphify_image }}\">\n```\n\nOf course, there are customizations available. However, I have just demonstrated the easiest and shortest way to accomplish OG image generation. Some of the customizations you may want are listed below. All these customizations and features available in this package are [documented here](https:\/\/ibnnajjaar.gitbook.io\/graphify\/):\n\n1. Customize default OG image URL using **`getOpenGraphImageUrlField()`**\n2. Manually trigger image generation using **`$yourModel->generateGraphify();`**\n3. Add a fallback image\n4. Select a custom disk for storing OG images\n5. Select a custom directory for storing OG images in the given disk\n6. Customize the view used to render OG image\n7. Customize the file name of the OG image\n8. Define which fields that will auto trigger an update of OG image when changed.\n9. Take control of the save process to customize how the OG image is saved, for example, to save it in Spatie media library collection.\n10. Turn on and off the OG image creation events\n\nIn conclusion, the Graphify package simplifies the process of creating custom Open Graph images, which can improve the visibility and shareability of your blog posts on social media.",
        "published_at": "2023-03-06T03:00:00.000000Z",
        "status": "published",
        "post_type": "post",
        "is_menu_item": false,
        "og_image_url": "adding-a-custom-open-graph-image-to-posts.png",
        "author_id": 2,
        "created_at": "2023-05-23T22:01:07.000000Z",
        "updated_at": "2023-05-23T22:01:07.000000Z"
    },
    {
        "id": 8,
        "title": "How to Add Translatable Enum Options in Laravel",
        "slug": "how-to-add-translatable-enum-options-in-laravel",
        "excerpt": "This article explores a solution for displaying enum values in a translatable format in Laravel. Enums in Laravel are useful in defining a fixed set of values, but they don't provide a built-in way to display those values in different languages. I'll show you how to create translatable string values for enums and retrieve them easily. I'll also demonstrate how to simplify this process using an interface and a trait. With this approach, you can easily display enum values in any language supported by your Laravel app.",
        "content": "Let's discuss Enums in Laravel. Although there are numerous tutorials on how to use enums in Laravel and how to validate them, today I'd like to talk about something I discovered while using enums.\n\nAs a Maldivian, I frequently need to display enum values in my locale language, and enums do not support this out of the box. Allow me to demonstrate how I resolved this problem.\n\nFor the context of this article, we'll be using a Post model. Let's create a post migration with the following code (most of the fields have been removed for clarity).\n\n```php\nSchema::create('posts', function (Blueprint $table) {\n    $table->id();\n    $table->string('title');\n    $table->text('content')->nullable();\n    $table->string('status');\n    $table->timestamps();\n});\n```\nNow let's create an enum for the status. You can place them wherever you like, but I usually put them in the `app\/Support\/Enums` directory.\n\n```php\nenum PostStatuses: string\n{\n    case DRAFT = 'draft';\n    case PUBLISHED = 'published';\n}\n```\nNow let's update the post model to use the enum.\n\n```php\nclass Post extends Model\n{\n    protected $casts = [\n        'status' => PostStatuses::class\n    ];\n}\n```\nIf I create a post and call `$post->status`, it will now return a `PostStatuses` instance. However, even if I add the translation for `draft` and `published` to the lang file and change the app locale, it will not display the translation. Therefore, I started adding an options method for every enum with translatable strings.\n\n```php\nenum PostStatuses: string\n{\n    case DRAFT = 'draft';\n    case PUBLISHED = 'published';\n\n    public static function options(): array\n    {\n        return [\n            self::DRAFT->value => __('Draft'), \n            self::PUBLISHED->value => __('Published'), \n        ];\n    }\n}\n```\nThis allows me to easily fetch the translatable string as shown below.\n\n```php\n\\App\\Support\\Enums\\PostStatuses::options()[$post->status->value];\n```\nI can further simplify this and add it as a method to the enum class.\n\n```php\npublic function getLabel(): string\n{\n    return self::options()[$this->value];\n}\n```\nAs a result, I can now get the translatable string value by simply calling `getLabel()` on the status as shown below.\n\n```php\n$post->status->getLabel();\n```\nThis will work, but let me show you what my final implementation looks like.\n\n```php\n\/\/ Enum\nenum PostStatuses: string implements Translatable\n{\n\n    use HasTranslatableLabels;\n    \n    case DRAFT = 'draft';\n    case PUBLISHED = 'published';\n\n    public static function options(): array\n    {\n        return [\n            self::DRAFT->value => __('Draft'),\n            self::PUBLISHED->value => __('Published'),\n        ];\n    }\n\n}\n```\n```php\n\/\/ Enum Interface\ninterface Translatable\n{\n\n    public static function options(): array;\n\n    public function getLabel(): string;\n\n}\n```\n```php\n\/\/ Enum Trait\ntrait HasTranslatableLabels\n{\n\n    public function getLabel(): string\n    {\n        return self::options()[$this->value];\n    }\n\n}\n```\nIf you have any ideas or thoughts about this article, feel free to leave a comment on my Twitter post. Thanks for reading, and have a great day!",
        "published_at": "2023-03-16T15:00:00.000000Z",
        "status": "published",
        "post_type": "post",
        "is_menu_item": false,
        "og_image_url": "how-to-add-translatable-enum-options-in-laravel.png",
        "author_id": 2,
        "created_at": "2023-05-23T22:01:09.000000Z",
        "updated_at": "2023-05-23T22:01:09.000000Z"
    },
    {
        "id": 9,
        "title": "Securing Your Files: How to Implement Private File Storage and Authorization in Laravel",
        "slug": "securing-your-files-in-laravel",
        "excerpt": "In this tutorial, we will delve into the process of achieving this level of file security using the powerful Spatie media library within the Laravel framework. We will explore the steps required to ensure that files are stored privately and can only be retrieved by authorized users. By the end of this tutorial, you will possess a comprehensive understanding of how to implement robust file protection and access controls in your Laravel applications, enhancing data confidentiality and user security.",
        "content": "When developing a system, there are instances where it becomes necessary to safeguard uploaded files. By default, these files are usually stored in the public directory, making them accessible to anyone with the corresponding link. However, in real-world applications, certain files should only be accessible to specific authorized users. Consider scenarios such as storing personal information like passport copies or other sensitive documents, where it is imperative to prevent unauthorized access.\n\nIn this tutorial, we will delve into the process of achieving this level of file security using the powerful Spatie media library within the Laravel framework. We will explore the steps required to ensure that files are stored privately and can only be retrieved by authorized users. By the end of this tutorial, you will possess a comprehensive understanding of how to implement robust file protection and access controls in your Laravel applications, enhancing data confidentiality and user security.\n\n## Scenario\n\nWe are going to create a Document model and then associate each document with a user. Each document will have a file associated with it.\n\n### Migration:\n\n```php\nSchema::create('documents', function (Blueprint $table) {\n    $table->id();\n    $table->string('name');\n    $table->foreignId('user_id')->constrained()->cascadeOnDelete();\n    $table->timestamps();\n});\n```\n\n### Models:\n\n```php\n<?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\Relations\\BelongsTo;\nuse Spatie\\MediaLibrary\\HasMedia;\nuse Spatie\\MediaLibrary\\InteractsWithMedia;\n\nclass Document extends Model implements HasMedia\n{\n    use HasFactory;\n    use InteractsWithMedia;\n\n    protected $fillable = ['name'];\n\n    public function user(): BelongsTo\n    {\n        return $this->belongsTo(User::class);\n    }\n\n    public function registerMediaCollections(): void\n    {\n        $this->addMediaCollection('file')\n            ->singleFile();\n    }\n}\n\n```\n\nHere, a file is associated with each Document record.\n\n### Routes\n\n```php\nRoute::middleware('auth')->group(function () {\n    Route::resource('documents', DocumentController::class);\n});\n```\n\n### Controller\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Models\\Document;\nuse Illuminate\\Foundation\\Auth\\Access\\AuthorizesRequests;\nuse Illuminate\\Http\\Request;\n\nclass DocumentController extends Controller\n{\n\n    public function index(Request $request)\n    {\n        $documents = Document::all();\n       return view('web.documents.index', compact('documents'));\n    }\n\n    public function create(Request $request)\n    {\n        return view('web.documents.create', [\n            'document' => new Document(),\n        ]);\n    }\n\n    public function store(Request $request)\n    {\n        $request->validate([\n            'name' => ['required', 'string'],\n            'document' => ['required', 'file'],\n        ]);\n\n        $document = new Document();\n        $document->name = $request->name;\n        $document->user()->associate($request->user());\n        $document->save();\n\n        $document->addMedia($request->file('document'))->toMediaCollection('file');\n\n        return redirect()->route('documents.show', $document);\n    }\n\n    public function show(Request $request, Document $document)\n    {\n        return view('web.documents.show', compact('document'));\n    }\n}\n\n```\n\nHere, an authenticated user may submit a file with a name to the store method, and it will create a Document record with the name. The user will be associated with the document. Additionally, the submitted file will also be associated with the document.\n\n### The Problem\n\nHowever, if you want to download the file, you will need to provide a link to the given file. One such way to do this would be by adding a link to the show method as shown below:\n\n```php\n<a href=\"{{ $document->getFirstMediaUrl('file') }}\">\n    {{ $document->name }}\n<\/a>\n\n```\n\nUsing the above method, a user can click on the link and the file will be downloaded. Unfortunately, this is not very secure, as anyone with the link can download this file, even if they are not authenticated, because the URL is a direct link to the file with no authorization in between.\n\n### The Solution\n\n**Step 1**\n\nFirst, let's move the file to a location where you cannot make a direct link to the file. You can do this by defining a new disk under `disks` in the `config\/filesystems.php` file.\n\n```php\n  'private_uploads' => [\n      'driver' => 'local',\n      'root' => storage_path('private_uploads'),\n  ],\n```\n\nNow, any file saved under this disk will not be accessible to the public directly, as it is stored in the `storage\/private_uploads` directory, which is not symlinked to the public directory. Since the storage directory sits at the same level as the public directory, no direct link can be established to anything inside the storage directory.\n\n**Step 2**\n\nUpdate the media collection in the Model to use the `private_uploads` disk.\n\n```php\npublic function registerMediaCollections(): void\n{\n    $this->addMediaCollection('file')\n        ->useDisk('private_uploads')\n        ->singleFile();\n}\n```\n\nThis ensures that all the files associated with the file collection will be saved in the `private_uploads` disk.\n\n**Step 3**\n\nNow that there is no direct link to the file, we need a way for users to download the file when it is required. So, let's add a route for that.\n\n```php\nRoute::get('documents\/{document}\/download', [DocumentController::class, 'download'])->name('documents.download');\n```\n\nAnd then let's implement that method in the controller.\n\n```php\npublic function download(Document $document)\n{\n  \/\/ check if the user is authorized to download it\n  if (auth()->user()->id != $document->user_id) {\n\t  abort(403);\n  }\n  \n\t$media = $document->getFirstMedia('file');\n\treturn response()->download($media->getPath(), $media->file_name);\n}\n```\n\nNow we have added an authorization layer before the file is served to the user.\n\n**Step 4**\nInstead of using the `getFirstMediaUrl` method to retrieve the link, update it to direct to the implemented route.\n\n```php\n<a href=\"{{ route('documents.download', $document) }}\">\n    {{ $document->name }},\n<\/a>\n```\n\nThis would do the trick, but we can clean things up a bit more.\n\n## Cleaning things up\n\nFirst, let's create a policy method.\n\n```php\n<?php\n\nnamespace App\\Policies;\n\nuse App\\Models\\Document;\nuse App\\Models\\User;\n\nclass DocumentPolicy\n{\n\n    public function download(User $user, Document $document): bool\n    {\n        return $user->id == $document->user_id;\n    }\n}\n\n```\n\nNow, use the policy in the controller.\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Models\\Document;\nuse Illuminate\\Foundation\\Auth\\Access\\AuthorizesRequests;\nuse Illuminate\\Http\\Request;\n\nclass DocumentController extends Controller\n{\n    use AuthorizesRequests;\n    \n    \/\/...\n    \n\t\tpublic function download(Document $document)\n    {\n        $this->authorize('download', $document); \/\/ makes things more Laravel, don't you think?\n\n        $media = $document->getFirstMedia('file');\n        return response()->download($media->getPath(), $media->file_name);\n    }\n}\n```\n\nNext, let's retrieve that route we implemented using the `getFirstMediaUrl`. To do this, we need to override the `config\/media-library` file.\n\n```php\n\/*\n* When urls to files get generated, this class will be called. Use the default\n* if your files are stored locally above the site root or on s3.\n*\/\n'url_generator' => App\\Support\\CustomUrlGenerator::class,\n```\n\nWe do not have a `CustomUrlGenerator` class yet, so let's implement it.\n\n```php\n<?php\n\nnamespace App\\Support;\n\nuse Spatie\\MediaLibrary\\MediaCollections\\Models\\Media;\nuse Spatie\\MediaLibrary\\Support\\PathGenerator\\DefaultPathGenerator;\nuse Spatie\\MediaLibrary\\Support\\UrlGenerator\\DefaultUrlGenerator;\n\nclass CustomUrlGenerator extends DefaultUrlGenerator\n{\n\n    public function getUrl(): string\n    {\n\t\t    \/\/ Get the normal URL\n        $url = parent::getUrl();\n\n\t\t\t\t\/\/ Find the disk the media is using\n        $disk = $this->media->disk;\n        \n        if ($disk === 'private_uploads') { \/\/ if it is using the private_uploads disk\n        \n\t\t        \/\/ Then return our custom implemented route\n            return route('documents.download', $this->media->model);\n        }\n\n        return $url;\n    }\n}\n\n```\n\nNow, you can directly call `getFirstMediaUrl` on the document, and it will still return our custom route.\n\n```php\n<a href=\"{{ $document->getFirstMediaUrl('file') }}\">\n    {{ $document->name }},\n<\/a>\n```\n\n## What else can you do?\n\nWell, you can create a custom route to handle all the media downloads.\n\n```php\nRoute::get('documents\/{media}', [MediaController::class, 'show'])->name('media.show');\n```\n\nThen, you can implement an interface for all model policies of models that use `private_uploads`, defining who is authorized to download files from that model. After that, on the show method, get the model via `$media->model` and then call the download policy of that model before streaming it to the user. Plus, update the `CustomUrlGenerator` to match the implemented route.\n\nThis ensures you have one single route to download all private files, and all requests are checked for authorization.\n\nHope you like it!",
        "published_at": "2024-06-06T19:00:00.000000Z",
        "status": "published",
        "post_type": "post",
        "is_menu_item": false,
        "og_image_url": "securing-your-files-in-laravel.png",
        "author_id": 2,
        "created_at": "2024-06-07T10:19:48.000000Z",
        "updated_at": "2024-06-07T10:21:22.000000Z"
    },
    {
        "id": 10,
        "title": "Laravel hasOneThrough relationship, with a twist!",
        "slug": "laravel-hasonethrough-relationship-with-a-twist",
        "excerpt": "Laravel\u2019s `hasOneThrough` makes it easy to connect models through an intermediate one. But what if the database doesn\u2019t follow Laravel\u2019s naming conventions? This post explains the official usage and shows how to customize hasOneThrough to work with non-standard schemas, allowing direct access to related models.",
        "content": "Laravel\u2019s hasOneThrough relationship is like a shortcut: it lets one model reach another through an intermediate model, without manually chaining calls.\n\nBy default, it\u2019s pretty straightforward\u2014Laravel assumes the standard naming conventions and handles the magic. But sometimes the database schema doesn\u2019t play nice with conventions. That\u2019s where a little twist comes in: customizing the relationship so it works exactly how it\u2019s needed.\n\nIn this post, first the standard hasOneThrough from the Laravel docs is explained, and then a customized version for a Post \u2192 User \u2192 Department scenario shows how to make it work even when the tables don\u2019t follow Laravel\u2019s defaults.",
        "published_at": "2025-09-05T19:00:00.000000Z",
        "status": "draft",
        "post_type": "post",
        "is_menu_item": false,
        "og_image_url": "laravel-hasonethrough-relationship-with-a-twist.png",
        "author_id": 2,
        "created_at": "2025-09-06T13:53:19.000000Z",
        "updated_at": "2025-09-06T13:53:19.000000Z"
    }
]
